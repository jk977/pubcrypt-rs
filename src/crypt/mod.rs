#[cfg(test)]
mod tests;

use rand::Rng;
use std::{fmt, io, mem, str};

use crate::util::parse_words;
use math::{mod_exp, primes, BigNum};

pub use math::Num;
pub type Block = u32;

pub const BLOCK_BYTES: usize = mem::size_of::<Block>();
const PRIME_MIN: Num = Block::MAX as Num + 1;
const PRIME_MAX: Num = Num::MAX;

#[derive(Debug)]
pub struct Key {
    prime: Num,
    root: Num,
    value: Num,
}

impl fmt::Display for Key {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} {} {}", self.prime, self.root, self.value)
    }
}

impl str::FromStr for Key {
    type Err = io::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let [prime, root, value] = parse_words(s)?;
        Ok(Self { prime, root, value })
    }
}

#[derive(Debug)]
pub struct KeyPair {
    pub public: Key,
    pub private: Key,
}

impl KeyPair {
    /**
     * Generate a pair of keys, private and public, to use for encryption. The
     * return value is wrapped in a structure instead of just using a tuple to
     * avoid confusion about which is the public and which is the private key.
     */
    pub fn generate<T: Rng>(rng: &mut T) -> Self {
        let (prime, root) = primes::pick_random_with_root(PRIME_MIN, PRIME_MAX, rng);
        let priv_exp = rng.gen_range(1..prime - 1);
        let pub_exp = mod_exp(root, priv_exp, prime);

        Self {
            public: Key {
                prime,
                root,
                value: pub_exp,
            },
            private: Key {
                prime,
                root,
                value: priv_exp,
            },
        }
    }
}

/**
 * Encrypt `block` with the given key, using `r` for exponentiation.
 *
 * This function is separate from the randomly encrypted block to allow
 * deterministic testing.
 */
fn encrypt_block_det(block: Block, key: &Key, r: Num) -> (Num, Num) {
    assert!(key.prime > Block::MAX as Num);
    assert!(r < key.prime);
    assert!(r > 0);

    let er_mod_p = mod_exp(key.value, r, key.prime) as BigNum;
    let c1 = mod_exp(key.root, r, key.prime);
    let c2 = ((block as BigNum * er_mod_p) % key.prime as BigNum) as Num;
    (c1, c2)
}

/**
 * Encrypt `block` with the given public key and a random exponent generated by
 * `rng`.
 */
pub fn encrypt_block<T: Rng>(block: Block, key: &Key, rng: &mut T) -> (Num, Num) {
    encrypt_block_det(block, key, rng.gen_range(1..key.prime))
}

/**
 * Decrypt the ciphertext block represented by `c1` and `c2` with the given
 * private key.
 */
pub fn decrypt_block(c1: Num, c2: Num, key: &Key) -> Block {
    let c1_term = mod_exp(c1, key.prime - key.value - 1, key.prime) as BigNum;
    let c2_term = (c2 % key.prime) as BigNum;
    let result = (c1_term * c2_term) % key.prime as BigNum;

    assert!(result <= Block::MAX as BigNum);
    result as Block
}
