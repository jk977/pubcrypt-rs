use std::{
    fmt, io,
    mem::{self, MaybeUninit},
    str::{self, FromStr},
};

use rand::Rng;

pub use math::Num;
use math::{mod_exp, primes, BigNum};

#[cfg(test)]
mod tests;

pub type Block = u32;

pub const BLOCK_BYTES: usize = mem::size_of::<Block>();
const PRIME_MIN: Num = Block::MAX as Num + 1;
const PRIME_MAX: Num = Num::MAX;

/**
 * Parse `N` values of type `T` from `s`, delimited by whitespace, and return the
 * resulting array of values.
 */
fn parse_words<T: FromStr, const N: usize>(s: &str) -> io::Result<[T; N]> {
    macro_rules! make_data_err {
        ($msg: literal) => {
            io::Error::new(io::ErrorKind::InvalidData, $msg)
        };
    }

    let mut vals = MaybeUninit::<[T; N]>::uninit();
    let mut word_count = 0;

    for word in s.split_whitespace().map(str::parse) {
        if word_count == N {
            return Err(make_data_err!("too many values encountered while parsing"));
        }

        let val = word.map_err(|_| make_data_err!("failed to parse data"))?;

        unsafe {
            (vals.as_mut_ptr() as *mut T).add(word_count).write(val);
        }

        word_count += 1;
    }

    if word_count < N {
        Err(make_data_err!("not enough values to parse"))
    } else {
        unsafe { Ok(vals.assume_init()) }
    }
}

#[derive(Debug)]
pub struct Key {
    prime: Num,
    root: Num,
    value: Num,
}

impl fmt::Display for Key {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} {} {}", self.prime, self.root, self.value)
    }
}

impl str::FromStr for Key {
    type Err = io::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let [prime, root, value] = parse_words(s)?;
        Ok(Self { prime, root, value })
    }
}

#[derive(Debug)]
pub struct KeyPair {
    pub public: Key,
    pub private: Key,
}

impl KeyPair {
    /**
     * Generate a pair of keys, private and public, to use for encryption. The
     * return value is wrapped in a structure instead of just using a tuple to
     * avoid confusion about which is the public and which is the private key.
     */
    pub fn generate<T: Rng>(rng: &mut T) -> Self {
        let (prime, root) = primes::pick_random_with_root(PRIME_MIN, PRIME_MAX, rng);
        let priv_exp = rng.gen_range(1..prime - 1);
        let pub_exp = mod_exp(root, priv_exp, prime);

        Self {
            public: Key {
                prime,
                root,
                value: pub_exp,
            },
            private: Key {
                prime,
                root,
                value: priv_exp,
            },
        }
    }
}

/**
 * Encrypt `block` with the given key, using `r` for exponentiation.
 *
 * This function is separate from the randomly encrypted block to allow
 * deterministic testing.
 */
fn encrypt_block_det(block: Block, key: &Key, r: Num) -> (Num, Num) {
    assert!(key.prime > Block::MAX as Num);
    assert!(r < key.prime);
    assert!(r > 0);

    let er_mod_p = mod_exp(key.value, r, key.prime) as BigNum;
    let c1 = mod_exp(key.root, r, key.prime);
    let c2 = ((block as BigNum * er_mod_p) % key.prime as BigNum) as Num;
    (c1, c2)
}

/**
 * Encrypt `block` with the given public key and a random exponent generated by
 * `rng`.
 */
pub fn encrypt_block<T: Rng>(block: Block, key: &Key, rng: &mut T) -> (Num, Num) {
    encrypt_block_det(block, key, rng.gen_range(1..key.prime))
}

/**
 * Decrypt the ciphertext block represented by `c1` and `c2` with the given
 * private key.
 */
pub fn decrypt_block(c1: Num, c2: Num, key: &Key) -> Block {
    let c1_term = mod_exp(c1, key.prime - key.value - 1, key.prime) as BigNum;
    let c2_term = (c2 % key.prime) as BigNum;
    let result = (c1_term * c2_term) % key.prime as BigNum;

    assert!(result <= Block::MAX as BigNum);
    result as Block
}
